import re


""" 
'''
В России применяются регистрационные знаки нескольких видов.
Общего в них то, что они состоят из цифр и букв. Причём используются только 12 букв кириллицы, имеющие графические аналоги в латинском алфавите 
— А, В, Е, К, М, Н, О, Р, С, Т, У и Х.
У частных легковых автомобилях номера — это буква, три цифры, две буквы, затем две или три цифры с кодом региона.
У такси — две буквы, три цифры, затем две или три цифры с кодом региона. Есть также и другие виды, но в этой задаче они не понадобятся.
Вам потребуется определить, является ли последовательность букв корректным номером указанных двух типов, и если является, то каким.
'''

На вход даются строки, которые претендуют на то, чтобы быть номером. Определите тип номера. Буквы в номерах — заглавные русские. Маленькие и английские для простоты можно игнорировать.
nomera = ['С227НА777','КУ22777 ','Т22В7477 ','М227К19У9 ',' С227НА777 ']

def Opredelenie(nomer):
    if re.fullmatch(r'[АВЕКМНОРСТУХ]\d{3}[АВЕКМНОРСТУХ]{2}\d{2,3}', nomer) :
        return 'Private'
    elif re.fullmatch(r'[АВЕКМНОРСТУХ]{2}\d{2}\d{2,3}', nomer) :
        return 'Taxi'
    else:
        return 'Fail'

for i in range(0,len(nomera)):
    print(Opredelenie(nomera[i].replace(' ','')))
 
 """




""" 
'''Слово — это последовательность из букв (русских или английских), внутри которой могут быть дефисы.
На вход даётся текст, посчитайте, сколько в нём слов.'''
text = '''Он --- серо-буро-малиновая редиска!! #
>>>:-> 
А не кот. 
www.kot.ru'''
print(re.findall(r'(?:[A-Za-zА-Яа-яёЁ]+[-]?)+',text)) """


""" '''На вход даётся текст. Необходимо вывести все e-mail адреса, которые в нём встречаются'''
text = ''' Иван Иванович! 
Нужен ответ на письмо от ivanoffffffff@ivan-chai.ru
Не забудьте поставить в копию 
serge'o-lupin@mail.ru- это важно. '''

result = re.findall(r'\b[A-Za-z0-9][0-9A-Za-z._+\'-]{0,62}[A-Za-z0-9]@[A-Za-z0-9][0-9A-Za-z.-]*[A-Za-z0-9]\b',text)
for i in range(len(result)-1,-1,-1):
   if len(result[i][result[i].find('@')+1:]) > 255:
     result.pop(i)
print(result)
 """


"""   Вовочка подготовил одно очень важное письмо, но везде указал неправильное время.
Поэтому нужно заменить все вхождения времени на строку (TBD). 
Время — это строка вида HH:MM:SS или HH:MM, в которой HH — число от 00 до 23, а MM и SS — число от 00 до 59. 

text = '''Уважаемые! Если вы к 09:00 не вернёте 
чемодан, то уже в 09:00:01 я за себя не отвечаю. 
PS. С отношением 25:50 всё нормально!'''

result = re.sub(r'(?:[0-1][0-9]|2[0-3])(?::[0-5][0-9]){1,2}','(TBD)',text) #Есть вопросы к 29:00:01
print(result) """



""" Владимиру потребовалось срочно запутать финансовую документацию. Но так, чтобы это было обратимо.
Он не придумал ничего лучше, чем заменить каждое целое число (последовательность цифр) на его куб. Помогите ему.

text = '''Было закуплено 12 единиц техники 
по 410.37 рублей. takze 15,5+3=6'''

def cube(num):
    return str(int(num[0])**3)

result = re.sub(r'\d+',cube,text)
print(result)
 """


""" Акростих — осмысленный текст, сложенный из начальных букв каждой строки стихотворения.
Акроним — вид аббревиатуры, образованной начальными звуками (напр. НАТО, вуз, НАСА, ТАСС), которое можно произнести слитно (в отличие от аббревиатуры, которую произносят «по буквам», например: КГБ — «ка-гэ-бэ»).
На вход даётся текст. Выведите слитно первые буквы каждого слова. Буквы необходимо выводить заглавными.

text ='''микоян авиацию снабдил алкоголем, 
народ доволен работой авиаконструктора'''

print(''.join(re.findall(r'\b\w',text)).upper())

[ЙйЦцКкНнГгШшЩщЗзХхЪъФфВвПпРрЛлДдЖжЧчСсМмТтЬьБб]
 """



""" Хайку — жанр традиционной японской лирической поэзии века, известный с XIV века.
Оригинальное японское хайку состоит из 17 слогов, составляющих один столбец иероглифов. 
Особыми разделительными словами — кирэдзи — текст хайку делится на части из 5, 7 и снова 5 слогов. 
При переводе хайку на западные языки традиционно вместо разделительного слова использую разрыв строки и,
таким образом, хайку записываются как трёхстишия.
Перед вами трёхстишия, которые претендуют на то, чтобы быть хайку. В качестве разделителя строк используются символы /.
Если разделители делят текст на строки, в которых 5/7/5 слогов, то выведите «Хайку!».
Если число строк не равно 3, то выведите строку «Не хайку. Должно быть 3 строки.» Иначе выведите строку вида «Не хайку.
В i строке слогов не s, а j.», где строка i — самая ранняя, в которой количество слогов неправильное.

text = '''Жизнь скоротечна… / Думает ли об этом / Маленький мальчик.'''

def hayku(text):
  
    if text.count('/') !=2:
        return 'Не хайку. Должно быть 3 строки.'
    hauykuString = text.split('/')
    hauykuSylls = []
    for i in range(0,len(hauykuString)):
        hauykuSylls.append(re.findall(r'[АаОоЕеЭэЫыЯяИиЮюУуЁё]',hauykuString[i])) 
    if len(hauykuSylls[0]) != 5:
        return f'Не хайку. В 1 строке слогов не 5, а {len(hauykuSylls[0])}'
    elif len(hauykuSylls[1]) != 7:
        return f'Не хайку. В 2 строке слогов не 7, а {len(hauykuSylls[0])}'
    elif len(hauykuSylls[2]) != 5:
        return f'Не хайку. В 3 строке слогов не 5, а {len(hauykuSylls[0])}'
    else:
        return 'Хайку!'

print(hayku(text)) """


""" '''Владимир написал свой открытый проект, именуя переменные в стиле «ВерблюжийРегистр».
И только после того, как написал о нём статью, он узнал, что в питоне для имён переменных принято использовать подчёркивания для разделения слов 
(under_score). 
Нужно срочно всё исправить, пока его не «закидали тапками».
Задача могла бы оказаться достаточно сложной, но, к счастью, Владимир совсем не использовал строковых констант и классов.
Поэтому любая последовательность букв и цифр, внутри которой есть заглавные, — это имя переменной, которое нужно поправить.'''
text = '''MyVar17 = OtherVar + YetAnother2Var 
TheAnswerToLifeTheUniverseAndEverything = 42'''

result = re.sub(r'(.)([A-Z])',r'\1_\2',text).lower()
print(result) """


""" Довольно распространённая ошибка ошибка — это повтор слова.
Вот в предыдущем предложении такая допущена. Необходимо исправить каждый такой повтор (слово, один или несколько пробельных символов, и снова то же слово).
text = '''Довольно распространённая ошибка ошибка — это лишний повтор повтор слова слова. Смешно, не не правда ли? 
Не нужно портить хор хоровод.'''
result = re.sub(r'\b(\w+) (\1)',r'\1',text, re.IGNORECASE)
print(result) """



""" zad = '''Для простоты будем считать словом любую последовательность букв, цифр и знаков _ (то есть символов \w).
Дан текст. Необходимо найти в нём любой фрагмент, где сначала идёт слово «олень», затем не более 5 слов, и после этого идёт слово «заяц».'''

text = '''Да он олень, а не заяц!'''
print(re.findall(r'олень(?:\S? ?\w*\S?){0,5} заяц',text)) """


